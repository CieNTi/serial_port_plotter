<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Emanuel Eichhammer" />
<meta name="copyright" content="(C) 2011-2022 Emanuel Eichhammer" />
<title>QCPPolarGraph Class Reference</title>
<link href="qcp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<a class="headerLink"  href="index.html">Main Page</a> &middot;
<a class="headerLink"  href="classoverview.html">Class Overview</a> &middot;
<a class="headerLink"  href="hierarchy.html">Hierarchy</a> &middot;
<a class="headerLink"  href="annotated.html">All Classes</a> &middot;
<a class="headerLink"  href="pages.html">Special Pages</a>
<!-- Generated by Doxygen 1.8.12 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Functions</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pro-methods">Protected Functions</a>  </div>
  <div class="headertitle">
<div class="title">QCPPolarGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A radial graph used to display data in polar plots.  
 <a href="classQCPPolarGraph.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for QCPPolarGraph:</div>
<div class="dyncontent">
<div class="center"><img src="classQCPPolarGraph__inherit__graph.png" border="0" usemap="#QCPPolarGraph_inherit__map" alt="Inheritance graph"/></div>
<map name="QCPPolarGraph_inherit__map" id="QCPPolarGraph_inherit__map">
<area shape="rect" id="node2" href="classQCPLayerable.html" title="Base class for all drawable objects. " alt="" coords="9,5,111,29"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1970d7ea3fb60006fad24ce3218e4b40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40">LineStyle</a> </td></tr>
<tr class="separator:a1970d7ea3fb60006fad24ce3218e4b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Functions</h2></td></tr>
<tr class="memitem:a1eb4ee188eccf0e76e805af62352e7e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a1eb4ee188eccf0e76e805af62352e7e8">QCPPolarGraph</a> (<a class="el" href="classQCPPolarAxisAngular.html">QCPPolarAxisAngular</a> *keyAxis, <a class="el" href="classQCPPolarAxisRadial.html">QCPPolarAxisRadial</a> *valueAxis)</td></tr>
<tr class="separator:a1eb4ee188eccf0e76e805af62352e7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2688b7f85cb4f1efe9a0646f6ac86f96"><td class="memItemLeft" align="right" valign="top"><a id="a2688b7f85cb4f1efe9a0646f6ac86f96"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const</td></tr>
<tr class="separator:a2688b7f85cb4f1efe9a0646f6ac86f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13330b1512186ab5e26ee0d7b207ceab"><td class="memItemLeft" align="right" valign="top"><a id="a13330b1512186ab5e26ee0d7b207ceab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiasedFill</b> () const</td></tr>
<tr class="separator:a13330b1512186ab5e26ee0d7b207ceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebee5dc8a47e99987eb83586017493c"><td class="memItemLeft" align="right" valign="top"><a id="a3ebee5dc8a47e99987eb83586017493c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiasedScatters</b> () const</td></tr>
<tr class="separator:a3ebee5dc8a47e99987eb83586017493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4314b867cddf9561435afb9432c70066"><td class="memItemLeft" align="right" valign="top"><a id="a4314b867cddf9561435afb9432c70066"></a>
QPen&#160;</td><td class="memItemRight" valign="bottom"><b>pen</b> () const</td></tr>
<tr class="separator:a4314b867cddf9561435afb9432c70066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2826a40c8c6d73b9060b232ad2937ad"><td class="memItemLeft" align="right" valign="top"><a id="af2826a40c8c6d73b9060b232ad2937ad"></a>
QBrush&#160;</td><td class="memItemRight" valign="bottom"><b>brush</b> () const</td></tr>
<tr class="separator:af2826a40c8c6d73b9060b232ad2937ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007c3c72304fd283ab7405c6de8b68ed"><td class="memItemLeft" align="right" valign="top"><a id="a007c3c72304fd283ab7405c6de8b68ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>periodic</b> () const</td></tr>
<tr class="separator:a007c3c72304fd283ab7405c6de8b68ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4f714e9e47a59806180ec087eb6262"><td class="memItemLeft" align="right" valign="top"><a id="a4a4f714e9e47a59806180ec087eb6262"></a>
<a class="el" href="classQCPPolarAxisAngular.html">QCPPolarAxisAngular</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keyAxis</b> () const</td></tr>
<tr class="separator:a4a4f714e9e47a59806180ec087eb6262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd08cc1a5fd2d66792c927313cda5d4"><td class="memItemLeft" align="right" valign="top"><a id="a0dd08cc1a5fd2d66792c927313cda5d4"></a>
<a class="el" href="classQCPPolarAxisRadial.html">QCPPolarAxisRadial</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>valueAxis</b> () const</td></tr>
<tr class="separator:a0dd08cc1a5fd2d66792c927313cda5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af285387b2070822e96cae70aaa075b81"><td class="memItemLeft" align="right" valign="top"><a id="af285387b2070822e96cae70aaa075b81"></a>
<a class="el" href="namespaceQCP.html#ac6cb9db26a564b27feda362a438db038">QCP::SelectionType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>selectable</b> () const</td></tr>
<tr class="separator:af285387b2070822e96cae70aaa075b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b61ef360f703084f3a8a24b5547c29"><td class="memItemLeft" align="right" valign="top"><a id="a66b61ef360f703084f3a8a24b5547c29"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>selected</b> () const</td></tr>
<tr class="separator:a66b61ef360f703084f3a8a24b5547c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec522b44d3944848f3151b280f782daa"><td class="memItemLeft" align="right" valign="top"><a id="aec522b44d3944848f3151b280f782daa"></a>
<a class="el" href="classQCPDataSelection.html">QCPDataSelection</a>&#160;</td><td class="memItemRight" valign="bottom"><b>selection</b> () const</td></tr>
<tr class="separator:aec522b44d3944848f3151b280f782daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038e3bc4f48c9e280f02978bee6e9c03"><td class="memItemLeft" align="right" valign="top"><a id="a038e3bc4f48c9e280f02978bee6e9c03"></a>
QSharedPointer&lt; <a class="el" href="plottable-graph_8h.html#a2e5583d1ae212f0deb10537cf975a15a">QCPGraphDataContainer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="separator:a038e3bc4f48c9e280f02978bee6e9c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35f92a3d9e02bc5c629034c7e0c13d0"><td class="memItemLeft" align="right" valign="top"><a id="aa35f92a3d9e02bc5c629034c7e0c13d0"></a>
<a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40">LineStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lineStyle</b> () const</td></tr>
<tr class="separator:aa35f92a3d9e02bc5c629034c7e0c13d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8cb1a257a4eadbb841b3dfc0997983"><td class="memItemLeft" align="right" valign="top"><a id="acb8cb1a257a4eadbb841b3dfc0997983"></a>
<a class="el" href="classQCPScatterStyle.html">QCPScatterStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scatterStyle</b> () const</td></tr>
<tr class="separator:acb8cb1a257a4eadbb841b3dfc0997983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e01eed16d4764f47dfb083a35000e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a9d9e01eed16d4764f47dfb083a35000e">setName</a> (const QString &amp;name)</td></tr>
<tr class="separator:a9d9e01eed16d4764f47dfb083a35000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731af0f0a0b45abe0f1df0d8d85a1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#ac731af0f0a0b45abe0f1df0d8d85a1a6">setAntialiasedFill</a> (bool enabled)</td></tr>
<tr class="separator:ac731af0f0a0b45abe0f1df0d8d85a1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68c64ca766ea18ace3347b73dd4be81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#ae68c64ca766ea18ace3347b73dd4be81">setAntialiasedScatters</a> (bool enabled)</td></tr>
<tr class="separator:ae68c64ca766ea18ace3347b73dd4be81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679c7b82b130fff72cdf27006904c5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a679c7b82b130fff72cdf27006904c5e0">setPen</a> (const QPen &amp;pen)</td></tr>
<tr class="separator:a679c7b82b130fff72cdf27006904c5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a0596f6a9bf583dc8d0cbe7c9df559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#ad8a0596f6a9bf583dc8d0cbe7c9df559">setBrush</a> (const QBrush &amp;brush)</td></tr>
<tr class="separator:ad8a0596f6a9bf583dc8d0cbe7c9df559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7d5959492ef2ed07aa684cb0eea8ff"><td class="memItemLeft" align="right" valign="top"><a id="a3b7d5959492ef2ed07aa684cb0eea8ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPeriodic</b> (bool enabled)</td></tr>
<tr class="separator:a3b7d5959492ef2ed07aa684cb0eea8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19976195e63c7a1d7d078230454f8e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a19976195e63c7a1d7d078230454f8e76">setKeyAxis</a> (<a class="el" href="classQCPPolarAxisAngular.html">QCPPolarAxisAngular</a> *axis)</td></tr>
<tr class="separator:a19976195e63c7a1d7d078230454f8e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0196a1af08db30ff8ff4c324a139047a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a0196a1af08db30ff8ff4c324a139047a">setValueAxis</a> (<a class="el" href="classQCPPolarAxisRadial.html">QCPPolarAxisRadial</a> *axis)</td></tr>
<tr class="separator:a0196a1af08db30ff8ff4c324a139047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69bb9f6074ba180e74e535fd6494f96"><td class="memItemLeft" align="right" valign="top">Q_SLOT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#ab69bb9f6074ba180e74e535fd6494f96">setSelectable</a> (<a class="el" href="namespaceQCP.html#ac6cb9db26a564b27feda362a438db038">QCP::SelectionType</a> selectable)</td></tr>
<tr class="separator:ab69bb9f6074ba180e74e535fd6494f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cc3f205eeb153dd3a28c11b996ccb2"><td class="memItemLeft" align="right" valign="top">Q_SLOT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#ab5cc3f205eeb153dd3a28c11b996ccb2">setSelection</a> (<a class="el" href="classQCPDataSelection.html">QCPDataSelection</a> selection)</td></tr>
<tr class="separator:ab5cc3f205eeb153dd3a28c11b996ccb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552b56a361f68c92dda9aafd6defae07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a552b56a361f68c92dda9aafd6defae07">setData</a> (QSharedPointer&lt; <a class="el" href="plottable-graph_8h.html#a2e5583d1ae212f0deb10537cf975a15a">QCPGraphDataContainer</a> &gt; data)</td></tr>
<tr class="separator:a552b56a361f68c92dda9aafd6defae07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd6c410e010dfd6f49c52a00a255e3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#aefd6c410e010dfd6f49c52a00a255e3d">setData</a> (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values, bool alreadySorted=false)</td></tr>
<tr class="separator:aefd6c410e010dfd6f49c52a00a255e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68249ca5e6d17d0133f62a90a144daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#aa68249ca5e6d17d0133f62a90a144daf">setLineStyle</a> (<a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40">LineStyle</a> ls)</td></tr>
<tr class="separator:aa68249ca5e6d17d0133f62a90a144daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2e656e2e4888ebdf54dffcf734b44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#adb2e656e2e4888ebdf54dffcf734b44b">setScatterStyle</a> (const <a class="el" href="classQCPScatterStyle.html">QCPScatterStyle</a> &amp;style)</td></tr>
<tr class="separator:adb2e656e2e4888ebdf54dffcf734b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b669ceaf3d40378426db1bb727d778f"><td class="memItemLeft" align="right" valign="top"><a id="a6b669ceaf3d40378426db1bb727d778f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addData</b> (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values, bool alreadySorted=false)</td></tr>
<tr class="separator:a6b669ceaf3d40378426db1bb727d778f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868519cb1833105e8c1895e21394bfcd"><td class="memItemLeft" align="right" valign="top"><a id="a868519cb1833105e8c1895e21394bfcd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addData</b> (double key, double value)</td></tr>
<tr class="separator:a868519cb1833105e8c1895e21394bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5a1ba1991779424a53560817f43cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#afd5a1ba1991779424a53560817f43cf6">coordsToPixels</a> (double key, double value, double &amp;x, double &amp;y) const</td></tr>
<tr class="separator:afd5a1ba1991779424a53560817f43cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71f91631a77fc4dc30e1a24e2bb9b7a"><td class="memItemLeft" align="right" valign="top"><a id="ad71f91631a77fc4dc30e1a24e2bb9b7a"></a>
const QPointF&#160;</td><td class="memItemRight" valign="bottom"><b>coordsToPixels</b> (double key, double value) const</td></tr>
<tr class="separator:ad71f91631a77fc4dc30e1a24e2bb9b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84283d7d4a749b8152416dffb712029"><td class="memItemLeft" align="right" valign="top"><a id="aa84283d7d4a749b8152416dffb712029"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pixelsToCoords</b> (double x, double y, double &amp;key, double &amp;value) const</td></tr>
<tr class="separator:aa84283d7d4a749b8152416dffb712029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd7d72caa4ef736641a794838324e7d"><td class="memItemLeft" align="right" valign="top"><a id="aadd7d72caa4ef736641a794838324e7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pixelsToCoords</b> (const QPointF &amp;pixelPos, double &amp;key, double &amp;value) const</td></tr>
<tr class="separator:aadd7d72caa4ef736641a794838324e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d6dd17af9fc2fdc01ac5ad73a60a60"><td class="memItemLeft" align="right" valign="top"><a id="a52d6dd17af9fc2fdc01ac5ad73a60a60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rescaleAxes</b> (bool onlyEnlarge=false) const</td></tr>
<tr class="separator:a52d6dd17af9fc2fdc01ac5ad73a60a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd162935a3a36671da9ac89fecd88a71"><td class="memItemLeft" align="right" valign="top"><a id="acd162935a3a36671da9ac89fecd88a71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rescaleKeyAxis</b> (bool onlyEnlarge=false) const</td></tr>
<tr class="separator:acd162935a3a36671da9ac89fecd88a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af235a40af6f32ac65eee484e73b45932"><td class="memItemLeft" align="right" valign="top"><a id="af235a40af6f32ac65eee484e73b45932"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rescaleValueAxis</b> (bool onlyEnlarge=false, bool inKeyRange=false) const</td></tr>
<tr class="separator:af235a40af6f32ac65eee484e73b45932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4eec96f4d64692ea9e66cede0314df"><td class="memItemLeft" align="right" valign="top"><a id="a5b4eec96f4d64692ea9e66cede0314df"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addToLegend</b> (<a class="el" href="classQCPLegend.html">QCPLegend</a> *legend)</td></tr>
<tr class="separator:a5b4eec96f4d64692ea9e66cede0314df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9976a18fc686dc7e4b40b06241866fd"><td class="memItemLeft" align="right" valign="top"><a id="ad9976a18fc686dc7e4b40b06241866fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addToLegend</b> ()</td></tr>
<tr class="separator:ad9976a18fc686dc7e4b40b06241866fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae73a0de017092f85e17521d2282760f"><td class="memItemLeft" align="right" valign="top"><a id="aae73a0de017092f85e17521d2282760f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromLegend</b> (<a class="el" href="classQCPLegend.html">QCPLegend</a> *legend) const</td></tr>
<tr class="separator:aae73a0de017092f85e17521d2282760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c96282b9444592c3a2f34c43e7675c"><td class="memItemLeft" align="right" valign="top"><a id="a55c96282b9444592c3a2f34c43e7675c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromLegend</b> () const</td></tr>
<tr class="separator:a55c96282b9444592c3a2f34c43e7675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4033ca80db907352e4188162f861d69a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a4033ca80db907352e4188162f861d69a">selectTest</a> (const QPointF &amp;pos, bool onlySelectable, QVariant *details=0) const</td></tr>
<tr class="separator:a4033ca80db907352e4188162f861d69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b20373bc32120d2abafed44ed31a5ba"><td class="memItemLeft" align="right" valign="top"><a id="a1b20373bc32120d2abafed44ed31a5ba"></a>
virtual <a class="el" href="classQCPPlottableInterface1D.html">QCPPlottableInterface1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>interface1D</b> ()</td></tr>
<tr class="separator:a1b20373bc32120d2abafed44ed31a5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8aab54372943277c040493bc19ff92"><td class="memItemLeft" align="right" valign="top"><a id="a0d8aab54372943277c040493bc19ff92"></a>
virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getKeyRange</b> (bool &amp;foundRange, <a class="el" href="namespaceQCP.html#afd50e7cf431af385614987d8553ff8a9">QCP::SignDomain</a> inSignDomain=<a class="el" href="namespaceQCP.html#afd50e7cf431af385614987d8553ff8a9aa38352ef02d51ddfa4399d9551566e24">QCP::sdBoth</a>) const</td></tr>
<tr class="separator:a0d8aab54372943277c040493bc19ff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd386c0454a26fed114ac7725fd2511"><td class="memItemLeft" align="right" valign="top"><a id="a8bd386c0454a26fed114ac7725fd2511"></a>
virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getValueRange</b> (bool &amp;foundRange, <a class="el" href="namespaceQCP.html#afd50e7cf431af385614987d8553ff8a9">QCP::SignDomain</a> inSignDomain=<a class="el" href="namespaceQCP.html#afd50e7cf431af385614987d8553ff8a9aa38352ef02d51ddfa4399d9551566e24">QCP::sdBoth</a>, const <a class="el" href="classQCPRange.html">QCPRange</a> &amp;inKeyRange=<a class="el" href="classQCPRange.html">QCPRange</a>()) const</td></tr>
<tr class="separator:a8bd386c0454a26fed114ac7725fd2511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classQCPLayerable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classQCPLayerable')"><img src="closed.png" alt="-"/>&#160;Public Functions inherited from <a class="el" href="classQCPLayerable.html">QCPLayerable</a></td></tr>
<tr class="memitem:a4f87f420cb2597e2b393aab934d2f099 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a4f87f420cb2597e2b393aab934d2f099">QCPLayerable</a> (<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *plot, QString targetLayer=QString(), <a class="el" href="classQCPLayerable.html">QCPLayerable</a> *<a class="el" href="classQCPLayerable.html#aa78b7e644d2c519e1a9a6f2ac5fcd858">parentLayerable</a>=nullptr)</td></tr>
<tr class="separator:a4f87f420cb2597e2b393aab934d2f099 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0297b944b6192b6d67d00bff41b6b70 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top"><a id="af0297b944b6192b6d67d00bff41b6b70"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>visible</b> () const</td></tr>
<tr class="separator:af0297b944b6192b6d67d00bff41b6b70 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473edb813a4c1929d6b6a8fe3ff3faf7 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top"><a id="a473edb813a4c1929d6b6a8fe3ff3faf7"></a>
<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parentPlot</b> () const</td></tr>
<tr class="separator:a473edb813a4c1929d6b6a8fe3ff3faf7 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b7e644d2c519e1a9a6f2ac5fcd858 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQCPLayerable.html">QCPLayerable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#aa78b7e644d2c519e1a9a6f2ac5fcd858">parentLayerable</a> () const</td></tr>
<tr class="separator:aa78b7e644d2c519e1a9a6f2ac5fcd858 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff4862e8c784c9f5986dbc1533ba2a4 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top"><a id="a5ff4862e8c784c9f5986dbc1533ba2a4"></a>
<a class="el" href="classQCPLayer.html">QCPLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>layer</b> () const</td></tr>
<tr class="separator:a5ff4862e8c784c9f5986dbc1533ba2a4 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cbd212fde2703cee076e204a475709 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top"><a id="a71cbd212fde2703cee076e204a475709"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiased</b> () const</td></tr>
<tr class="separator:a71cbd212fde2703cee076e204a475709 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bed99ddc396b48ce3ebfdc0418744f8 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a3bed99ddc396b48ce3ebfdc0418744f8">setVisible</a> (bool on)</td></tr>
<tr class="separator:a3bed99ddc396b48ce3ebfdc0418744f8 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d0da6d2de45a118886d2c8e16d5a54 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">Q_SLOT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab0d0da6d2de45a118886d2c8e16d5a54">setLayer</a> (<a class="el" href="classQCPLayer.html">QCPLayer</a> *layer)</td></tr>
<tr class="separator:ab0d0da6d2de45a118886d2c8e16d5a54 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25a0e7b897993b44447caee0f142083 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab25a0e7b897993b44447caee0f142083">setLayer</a> (const QString &amp;layerName)</td></tr>
<tr class="separator:ab25a0e7b897993b44447caee0f142083 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd43e89be4a553ead41652565ff0581 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">setAntialiased</a> (bool enabled)</td></tr>
<tr class="separator:a4fd43e89be4a553ead41652565ff0581 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab054e88f15d485defcb95e7376f119e7 inherit pub_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab054e88f15d485defcb95e7376f119e7">realVisibility</a> () const</td></tr>
<tr class="separator:ab054e88f15d485defcb95e7376f119e7 inherit pub_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:aebc7c58b7bd964a31f38210c0710d6af"><td class="memItemLeft" align="right" valign="top"><a id="aebc7c58b7bd964a31f38210c0710d6af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>selectionChanged</b> (bool selected)</td></tr>
<tr class="separator:aebc7c58b7bd964a31f38210c0710d6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3deaac26783c3d5ccee62eb6e89baa1"><td class="memItemLeft" align="right" valign="top"><a id="ab3deaac26783c3d5ccee62eb6e89baa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>selectionChanged</b> (const <a class="el" href="classQCPDataSelection.html">QCPDataSelection</a> &amp;selection)</td></tr>
<tr class="separator:ab3deaac26783c3d5ccee62eb6e89baa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6d9dfadb09284c6b19ebc80376680"><td class="memItemLeft" align="right" valign="top"><a id="ab0a6d9dfadb09284c6b19ebc80376680"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>selectableChanged</b> (<a class="el" href="namespaceQCP.html#ac6cb9db26a564b27feda362a438db038">QCP::SelectionType</a> selectable)</td></tr>
<tr class="separator:ab0a6d9dfadb09284c6b19ebc80376680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header signals_classQCPLayerable"><td colspan="2" onclick="javascript:toggleInherit('signals_classQCPLayerable')"><img src="closed.png" alt="-"/>&#160;Signals inherited from <a class="el" href="classQCPLayerable.html">QCPLayerable</a></td></tr>
<tr class="memitem:abbf8657cedea73ac1c3499b521c90eba inherit signals_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#abbf8657cedea73ac1c3499b521c90eba">layerChanged</a> (<a class="el" href="classQCPLayer.html">QCPLayer</a> *newLayer)</td></tr>
<tr class="separator:abbf8657cedea73ac1c3499b521c90eba inherit signals_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Functions</h2></td></tr>
<tr class="memitem:a9a7713734980adecbe53421795977806"><td class="memItemLeft" align="right" valign="top">virtual QRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a9a7713734980adecbe53421795977806">clipRect</a> () const</td></tr>
<tr class="separator:a9a7713734980adecbe53421795977806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a053fc53b7945cd2e3b93cef9cade9a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a2a053fc53b7945cd2e3b93cef9cade9a">draw</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter)</td></tr>
<tr class="separator:a2a053fc53b7945cd2e3b93cef9cade9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2e0f0209b63f2ba79ef95121b80fab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceQCP.html#a2ad6bb6281c7c2d593d4277b44c2b037">QCP::Interaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#aad2e0f0209b63f2ba79ef95121b80fab">selectionCategory</a> () const</td></tr>
<tr class="separator:aad2e0f0209b63f2ba79ef95121b80fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25e8bb9c15d27efdf1d9071bb1e74d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#acc25e8bb9c15d27efdf1d9071bb1e74d">applyDefaultAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const</td></tr>
<tr class="separator:acc25e8bb9c15d27efdf1d9071bb1e74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc6a4af76e45ce13cd4f544062ff8b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a> (QMouseEvent *event, bool additive, const QVariant &amp;details, bool *selectionStateChanged)</td></tr>
<tr class="separator:a1bc6a4af76e45ce13cd4f544062ff8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3372c079d5859f513d18384890945072"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a3372c079d5859f513d18384890945072">deselectEvent</a> (bool *selectionStateChanged)</td></tr>
<tr class="separator:a3372c079d5859f513d18384890945072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f607151debb2978b4883743c83a2a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#ad9f607151debb2978b4883743c83a2a8">drawLinePlot</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, const QVector&lt; QPointF &gt; &amp;lines) const</td></tr>
<tr class="separator:ad9f607151debb2978b4883743c83a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a42c1816fb6896db565018c2443f74"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a31a42c1816fb6896db565018c2443f74">drawFill</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, QVector&lt; QPointF &gt; *lines) const</td></tr>
<tr class="separator:a31a42c1816fb6896db565018c2443f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c02b5c9d9ae8cc3e01dffc880d3926d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a4c02b5c9d9ae8cc3e01dffc880d3926d">drawScatterPlot</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, const QVector&lt; QPointF &gt; &amp;scatters, const <a class="el" href="classQCPScatterStyle.html">QCPScatterStyle</a> &amp;style) const</td></tr>
<tr class="separator:a4c02b5c9d9ae8cc3e01dffc880d3926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fc02419f54a53225d51e81dd8bc24d"><td class="memItemLeft" align="right" valign="top"><a id="a59fc02419f54a53225d51e81dd8bc24d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drawLegendIcon</b> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, const QRectF &amp;rect) const</td></tr>
<tr class="separator:a59fc02419f54a53225d51e81dd8bc24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f6da1b827ccbe8c94c7f77ed12ee01"><td class="memItemLeft" align="right" valign="top"><a id="a25f6da1b827ccbe8c94c7f77ed12ee01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyFillAntialiasingHint</b> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const</td></tr>
<tr class="separator:a25f6da1b827ccbe8c94c7f77ed12ee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1a02b4517ce13b64f580784dc9053e"><td class="memItemLeft" align="right" valign="top"><a id="a7c1a02b4517ce13b64f580784dc9053e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyScattersAntialiasingHint</b> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const</td></tr>
<tr class="separator:a7c1a02b4517ce13b64f580784dc9053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b917f9396ede27e5b4f41a974b129d3"><td class="memItemLeft" align="right" valign="top"><a id="a0b917f9396ede27e5b4f41a974b129d3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>pointDistance</b> (const QPointF &amp;pixelPoint, QCPGraphDataContainer::const_iterator &amp;closestData) const</td></tr>
<tr class="separator:a0b917f9396ede27e5b4f41a974b129d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e6054d6a646a79829e4f1db548c199"><td class="memItemLeft" align="right" valign="top"><a id="a63e6054d6a646a79829e4f1db548c199"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>dataCount</b> () const</td></tr>
<tr class="separator:a63e6054d6a646a79829e4f1db548c199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984e21a4d3189d3fce60a3b883a86752"><td class="memItemLeft" align="right" valign="top"><a id="a984e21a4d3189d3fce60a3b883a86752"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getDataSegments</b> (QList&lt; <a class="el" href="classQCPDataRange.html">QCPDataRange</a> &gt; &amp;selectedSegments, QList&lt; <a class="el" href="classQCPDataRange.html">QCPDataRange</a> &gt; &amp;unselectedSegments) const</td></tr>
<tr class="separator:a984e21a4d3189d3fce60a3b883a86752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bf9db1ed01c787ce8b201485c71e7d"><td class="memItemLeft" align="right" valign="top"><a id="a20bf9db1ed01c787ce8b201485c71e7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawPolyline</b> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, const QVector&lt; QPointF &gt; &amp;lineData) const</td></tr>
<tr class="separator:a20bf9db1ed01c787ce8b201485c71e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2a1108806a35ce537ce11c89478877"><td class="memItemLeft" align="right" valign="top"><a id="a6b2a1108806a35ce537ce11c89478877"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getVisibleDataBounds</b> (QCPGraphDataContainer::const_iterator &amp;begin, QCPGraphDataContainer::const_iterator &amp;end, const <a class="el" href="classQCPDataRange.html">QCPDataRange</a> &amp;rangeRestriction) const</td></tr>
<tr class="separator:a6b2a1108806a35ce537ce11c89478877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ef86f65cf446fc46a012d3821fc7f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#ae3ef86f65cf446fc46a012d3821fc7f7">getLines</a> (QVector&lt; QPointF &gt; *lines, const <a class="el" href="classQCPDataRange.html">QCPDataRange</a> &amp;dataRange) const</td></tr>
<tr class="separator:ae3ef86f65cf446fc46a012d3821fc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6330a4bcd3c3263047ac05eaca3711f"><td class="memItemLeft" align="right" valign="top"><a id="ad6330a4bcd3c3263047ac05eaca3711f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getScatters</b> (QVector&lt; QPointF &gt; *scatters, const <a class="el" href="classQCPDataRange.html">QCPDataRange</a> &amp;dataRange) const</td></tr>
<tr class="separator:ad6330a4bcd3c3263047ac05eaca3711f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf991830f9069751c7a1ba9a79deea43"><td class="memItemLeft" align="right" valign="top"><a id="acf991830f9069751c7a1ba9a79deea43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getOptimizedLineData</b> (QVector&lt; <a class="el" href="classQCPGraphData.html">QCPGraphData</a> &gt; *lineData, const QCPGraphDataContainer::const_iterator &amp;begin, const QCPGraphDataContainer::const_iterator &amp;end) const</td></tr>
<tr class="separator:acf991830f9069751c7a1ba9a79deea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607f1e7d041b009e75e52fc221e2fd29"><td class="memItemLeft" align="right" valign="top"><a id="a607f1e7d041b009e75e52fc221e2fd29"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>getOptimizedScatterData</b> (QVector&lt; <a class="el" href="classQCPGraphData.html">QCPGraphData</a> &gt; *scatterData, QCPGraphDataContainer::const_iterator begin, QCPGraphDataContainer::const_iterator end) const</td></tr>
<tr class="separator:a607f1e7d041b009e75e52fc221e2fd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf5f03ca826775f86b238bca57515c5"><td class="memItemLeft" align="right" valign="top">QVector&lt; QPointF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPPolarGraph.html#a2cf5f03ca826775f86b238bca57515c5">dataToLines</a> (const QVector&lt; <a class="el" href="classQCPGraphData.html">QCPGraphData</a> &gt; &amp;data) const</td></tr>
<tr class="separator:a2cf5f03ca826775f86b238bca57515c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classQCPLayerable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classQCPLayerable')"><img src="closed.png" alt="-"/>&#160;Protected Functions inherited from <a class="el" href="classQCPLayerable.html">QCPLayerable</a></td></tr>
<tr class="memitem:ab20b7dbd8e0249ed61adb9622c427382 inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab20b7dbd8e0249ed61adb9622c427382">parentPlotInitialized</a> (<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *parentPlot)</td></tr>
<tr class="separator:ab20b7dbd8e0249ed61adb9622c427382 inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6567604818db90f4fd52822f8bc8376 inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#af6567604818db90f4fd52822f8bc8376">mousePressEvent</a> (QMouseEvent *event, const QVariant &amp;details)</td></tr>
<tr class="separator:af6567604818db90f4fd52822f8bc8376 inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eee1ba47fd69be111059ca3881933e4 inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a9eee1ba47fd69be111059ca3881933e4">mouseMoveEvent</a> (QMouseEvent *event, const QPointF &amp;startPos)</td></tr>
<tr class="separator:a9eee1ba47fd69be111059ca3881933e4 inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d79b005686f668622bbe66ac03ba2c inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#aa0d79b005686f668622bbe66ac03ba2c">mouseReleaseEvent</a> (QMouseEvent *event, const QPointF &amp;startPos)</td></tr>
<tr class="separator:aa0d79b005686f668622bbe66ac03ba2c inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4171e2e823aca242dd0279f00ed2de81 inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a4171e2e823aca242dd0279f00ed2de81">mouseDoubleClickEvent</a> (QMouseEvent *event, const QVariant &amp;details)</td></tr>
<tr class="separator:a4171e2e823aca242dd0279f00ed2de81 inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dfd7b8fd99c08ca54e09c362b6f022 inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a47dfd7b8fd99c08ca54e09c362b6f022">wheelEvent</a> (QWheelEvent *event)</td></tr>
<tr class="separator:a47dfd7b8fd99c08ca54e09c362b6f022 inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbe5a0c9a5674249982f5ca5f8e02bc inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a8cbe5a0c9a5674249982f5ca5f8e02bc">initializeParentPlot</a> (<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *parentPlot)</td></tr>
<tr class="separator:a8cbe5a0c9a5674249982f5ca5f8e02bc inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23c893671f1f6744ac235cf2204cf3a inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#aa23c893671f1f6744ac235cf2204cf3a">setParentLayerable</a> (<a class="el" href="classQCPLayerable.html">QCPLayerable</a> *<a class="el" href="classQCPLayerable.html#aa78b7e644d2c519e1a9a6f2ac5fcd858">parentLayerable</a>)</td></tr>
<tr class="separator:aa23c893671f1f6744ac235cf2204cf3a inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94484cfb7cbbddb7de522e9be71d9a4 inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#af94484cfb7cbbddb7de522e9be71d9a4">moveToLayer</a> (<a class="el" href="classQCPLayer.html">QCPLayer</a> *layer, bool prepend)</td></tr>
<tr class="separator:af94484cfb7cbbddb7de522e9be71d9a4 inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb663e375d2d36dc5c55021ee5a2119b inherit pro_methods_classQCPLayerable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#acb663e375d2d36dc5c55021ee5a2119b">applyAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, bool localAntialiased, <a class="el" href="namespaceQCP.html#ae55dbe315d41fe80f29ba88100843a0c">QCP::AntialiasedElement</a> overrideElement) const</td></tr>
<tr class="separator:acb663e375d2d36dc5c55021ee5a2119b inherit pro_methods_classQCPLayerable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A radial graph used to display data in polar plots. </p>
<dl class="section warning"><dt>Warning</dt><dd>In this <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> version, polar plots are a tech preview. Expect documentation and functionality to be incomplete, as well as changing public interfaces in the future. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1970d7ea3fb60006fad24ce3218e4b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1970d7ea3fb60006fad24ce3218e4b40">&sect;&nbsp;</a></span>LineStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40">QCPPolarGraph::LineStyle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines how the graph's line is represented visually in the plot. The line is drawn with the current pen of the graph (<a class="el" href="classQCPPolarGraph.html#a679c7b82b130fff72cdf27006904c5e0">setPen</a>). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#aa68249ca5e6d17d0133f62a90a144daf">setLineStyle</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1970d7ea3fb60006fad24ce3218e4b40a2015a1b1471431d25ddcf35cc6fdef56"></a>lsNone&#160;</td><td class="fielddoc"><p>data points are not connected with any lines (e.g. data only represented with symbols according to the scatter style, see <a class="el" href="classQCPPolarGraph.html#adb2e656e2e4888ebdf54dffcf734b44b">setScatterStyle</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1970d7ea3fb60006fad24ce3218e4b40af2efc561134fbc2c971a499877a9449d"></a>lsLine&#160;</td><td class="fielddoc"><p>data points are connected by a straight line </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1eb4ee188eccf0e76e805af62352e7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb4ee188eccf0e76e805af62352e7e8">&sect;&nbsp;</a></span>QCPPolarGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCPPolarGraph::QCPPolarGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPolarAxisAngular.html">QCPPolarAxisAngular</a> *&#160;</td>
          <td class="paramname"><em>keyAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPPolarAxisRadial.html">QCPPolarAxisRadial</a> *&#160;</td>
          <td class="paramname"><em>valueAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a graph which uses <em>keyAxis</em> as its angular and <em>valueAxis</em> as its radial axis. <em>keyAxis</em> and <em>valueAxis</em> must reside in the same <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>, and the radial axis must be associated with the angular axis. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.</p>
<p>The created <a class="el" href="classQCPPolarGraph.html" title="A radial graph used to display data in polar plots. ">QCPPolarGraph</a> is automatically registered with the <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> instance inferred from <em>keyAxis</em>. This <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> instance takes ownership of the <a class="el" href="classQCPPolarGraph.html" title="A radial graph used to display data in polar plots. ">QCPPolarGraph</a>, so do not delete it manually but use QCPPolarAxisAngular::removeGraph() instead.</p>
<p>To directly create a <a class="el" href="classQCPPolarGraph.html" title="A radial graph used to display data in polar plots. ">QCPPolarGraph</a> inside a plot, you shoud use the QCPPolarAxisAngular::addGraph method. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d9e01eed16d4764f47dfb083a35000e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e01eed16d4764f47dfb083a35000e">&sect;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The name is the textual representation of this plottable as it is displayed in the legend (<a class="el" href="classQCPLegend.html">QCPLegend</a>). It may contain any UTF-8 characters, including newlines. </p>

</div>
</div>
<a id="ac731af0f0a0b45abe0f1df0d8d85a1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac731af0f0a0b45abe0f1df0d8d85a1a6">&sect;&nbsp;</a></span>setAntialiasedFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setAntialiasedFill </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether fills of this plottable are drawn antialiased or not.</p>
<p>Note that this setting may be overridden by <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. </p>

</div>
</div>
<a id="ae68c64ca766ea18ace3347b73dd4be81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68c64ca766ea18ace3347b73dd4be81">&sect;&nbsp;</a></span>setAntialiasedScatters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setAntialiasedScatters </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether the scatter symbols of this plottable are drawn antialiased or not.</p>
<p>Note that this setting may be overridden by <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. </p>

</div>
</div>
<a id="a679c7b82b130fff72cdf27006904c5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679c7b82b130fff72cdf27006904c5e0">&sect;&nbsp;</a></span>setPen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setPen </td>
          <td>(</td>
          <td class="paramtype">const QPen &amp;&#160;</td>
          <td class="paramname"><em>pen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pen is used to draw basic lines that make up the plottable representation in the plot.</p>
<p>For example, the <a class="el" href="classQCPGraph.html">QCPGraph</a> subclass draws its graph lines with this pen.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#ad8a0596f6a9bf583dc8d0cbe7c9df559">setBrush</a> </dd></dl>

</div>
</div>
<a id="ad8a0596f6a9bf583dc8d0cbe7c9df559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a0596f6a9bf583dc8d0cbe7c9df559">&sect;&nbsp;</a></span>setBrush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setBrush </td>
          <td>(</td>
          <td class="paramtype">const QBrush &amp;&#160;</td>
          <td class="paramname"><em>brush</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.</p>
<p>For example, the <a class="el" href="classQCPGraph.html">QCPGraph</a> subclass draws the fill under the graph with this brush, when it's not set to Qt::NoBrush.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#a679c7b82b130fff72cdf27006904c5e0">setPen</a> </dd></dl>

</div>
</div>
<a id="a19976195e63c7a1d7d078230454f8e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19976195e63c7a1d7d078230454f8e76">&sect;&nbsp;</a></span>setKeyAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setKeyAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPolarAxisAngular.html">QCPPolarAxisAngular</a> *&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The key axis of a plottable can be set to any axis of a <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>, as long as it is orthogonal to the plottable's value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis (<a class="el" href="classQCustomPlot.html#a9a79cd0158a4c7f30cbc702f0fd800e4">QCustomPlot::xAxis</a>) as key axis and the y-axis (<a class="el" href="classQCustomPlot.html#af6fea5679725b152c14facd920b19367">QCustomPlot::yAxis</a>) as value axis.</p>
<p>Normally, the key and value axes are set in the constructor of the plottable (or <a class="el" href="classQCustomPlot.html#a2836a46e31d5aee174ae054c0aa6580b">QCustomPlot::addGraph</a> when working with QCPGraphs through the dedicated graph interface).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#a0196a1af08db30ff8ff4c324a139047a">setValueAxis</a> </dd></dl>

</div>
</div>
<a id="a0196a1af08db30ff8ff4c324a139047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0196a1af08db30ff8ff4c324a139047a">&sect;&nbsp;</a></span>setValueAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setValueAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPolarAxisRadial.html">QCPPolarAxisRadial</a> *&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The value axis of a plottable can be set to any axis of a <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>, as long as it is orthogonal to the plottable's key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis (<a class="el" href="classQCustomPlot.html#a9a79cd0158a4c7f30cbc702f0fd800e4">QCustomPlot::xAxis</a>) as key axis and the y-axis (<a class="el" href="classQCustomPlot.html#af6fea5679725b152c14facd920b19367">QCustomPlot::yAxis</a>) as value axis.</p>
<p>Normally, the key and value axes are set in the constructor of the plottable (or <a class="el" href="classQCustomPlot.html#a2836a46e31d5aee174ae054c0aa6580b">QCustomPlot::addGraph</a> when working with QCPGraphs through the dedicated graph interface).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#a19976195e63c7a1d7d078230454f8e76">setKeyAxis</a> </dd></dl>

</div>
</div>
<a id="ab69bb9f6074ba180e74e535fd6494f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69bb9f6074ba180e74e535fd6494f96">&sect;&nbsp;</a></span>setSelectable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setSelectable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceQCP.html#ac6cb9db26a564b27feda362a438db038">QCP::SelectionType</a>&#160;</td>
          <td class="paramname"><em>selectable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether and to which granularity this plottable can be selected.</p>
<p>A selection can happen by clicking on the <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> surface (When <a class="el" href="classQCustomPlot.html#a5ee1e2f6ae27419deca53e75907c27e5">QCustomPlot::setInteractions</a> contains <a class="el" href="namespaceQCP.html#a2ad6bb6281c7c2d593d4277b44c2b037a67148c8227b4155eca49135fc274c7ec">QCP::iSelectPlottables</a>), by dragging a selection rect (When <a class="el" href="classQCustomPlot.html#a810ef958ebe84db661c7288b526c0deb">QCustomPlot::setSelectionRectMode</a> is <a class="el" href="namespaceQCP.html#ac9aa4d6d81ac76b094f9af9ad2d3aacfa62c286e8da283a0cbb88ecac2f3f7506">QCP::srmSelect</a>), or programmatically by calling <a class="el" href="classQCPPolarGraph.html#ab5cc3f205eeb153dd3a28c11b996ccb2">setSelection</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#ab5cc3f205eeb153dd3a28c11b996ccb2">setSelection</a>, <a class="el" href="namespaceQCP.html#ac6cb9db26a564b27feda362a438db038">QCP::SelectionType</a> </dd></dl>

</div>
</div>
<a id="ab5cc3f205eeb153dd3a28c11b996ccb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cc3f205eeb153dd3a28c11b996ccb2">&sect;&nbsp;</a></span>setSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setSelection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPDataSelection.html">QCPDataSelection</a>&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets which data ranges of this plottable are selected. Selected data ranges are drawn differently (e.g. color) in the plot. This can be controlled via the selection decorator (see selectionDecorator).</p>
<p>The entire selection mechanism for plottables is handled automatically when <a class="el" href="classQCustomPlot.html#a5ee1e2f6ae27419deca53e75907c27e5">QCustomPlot::setInteractions</a> contains iSelectPlottables. You only need to call this function when you wish to change the selection state programmatically.</p>
<p>Using <a class="el" href="classQCPPolarGraph.html#ab69bb9f6074ba180e74e535fd6494f96">setSelectable</a> you can further specify for each plottable whether and to which granularity it is selectable. If <em>selection</em> is not compatible with the current <a class="el" href="namespaceQCP.html#ac6cb9db26a564b27feda362a438db038">QCP::SelectionType</a> set via <a class="el" href="classQCPPolarGraph.html#ab69bb9f6074ba180e74e535fd6494f96">setSelectable</a>, the resulting selection will be adjusted accordingly (see <a class="el" href="classQCPDataSelection.html#a17b84d852911531d229f4a76aa239a75">QCPDataSelection::enforceType</a>).</p>
<p>emits the selectionChanged signal when <em>selected</em> is different from the previous selection state.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#ab69bb9f6074ba180e74e535fd6494f96">setSelectable</a>, <a class="el" href="classQCPPolarGraph.html#a4033ca80db907352e4188162f861d69a">selectTest</a> </dd></dl>

</div>
</div>
<a id="a552b56a361f68c92dda9aafd6defae07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552b56a361f68c92dda9aafd6defae07">&sect;&nbsp;</a></span>setData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setData </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="plottable-graph_8h.html#a2e5583d1ae212f0deb10537cf975a15a">QCPGraphDataContainer</a> &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data container with the provided <em>data</em> container.</p>
<p>Since a QSharedPointer is used, multiple QCPPolarGraphs may share the same data container safely. Modifying the data in the container will then affect all graphs that share the container. Sharing can be achieved by simply exchanging the data containers wrapped in shared pointers: </p><div class="fragment"></div><!-- fragment --><p> If you do not wish to share containers, but create a copy from an existing container, rather use the <a class="el" href="classQCPDataContainer.html#ae7042bd534fc3ce7befa2ce3f790b5bf">QCPDataContainer&lt;DataType&gt;::set</a> method on the graph's data container directly: </p><div class="fragment"></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>addData </dd></dl>

</div>
</div>
<a id="aefd6c410e010dfd6f49c52a00a255e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd6c410e010dfd6f49c52a00a255e3d">&sect;&nbsp;</a></span>setData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setData </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alreadySorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>keys</em> and <em>values</em>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</p>
<p>If you can guarantee that the passed data points are sorted by <em>keys</em> in ascending order, you can set <em>alreadySorted</em> to true, to improve performance by saving a sorting run.</p>
<dl class="section see"><dt>See also</dt><dd>addData </dd></dl>

</div>
</div>
<a id="aa68249ca5e6d17d0133f62a90a144daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68249ca5e6d17d0133f62a90a144daf">&sect;&nbsp;</a></span>setLineStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setLineStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40">LineStyle</a>&#160;</td>
          <td class="paramname"><em>ls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets how the single data points are connected in the plot. For scatter-only plots, set <em>ls</em> to <a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40a2015a1b1471431d25ddcf35cc6fdef56">lsNone</a> and <a class="el" href="classQCPPolarGraph.html#adb2e656e2e4888ebdf54dffcf734b44b">setScatterStyle</a> to the desired scatter style.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#adb2e656e2e4888ebdf54dffcf734b44b">setScatterStyle</a> </dd></dl>

</div>
</div>
<a id="adb2e656e2e4888ebdf54dffcf734b44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2e656e2e4888ebdf54dffcf734b44b">&sect;&nbsp;</a></span>setScatterStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::setScatterStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCPScatterStyle.html">QCPScatterStyle</a> &amp;&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the visual appearance of single data points in the plot. If set to <a class="el" href="classQCPScatterStyle.html#adb31525af6b680e6f1b7472e43859349abd144c291ca274f77053ec68cab6c022">QCPScatterStyle::ssNone</a>, no scatter points are drawn (e.g. for line-only-plots with appropriate line style).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPScatterStyle.html" title="Represents the visual appearance of scatter points. ">QCPScatterStyle</a>, <a class="el" href="classQCPPolarGraph.html#aa68249ca5e6d17d0133f62a90a144daf">setLineStyle</a> </dd></dl>

</div>
</div>
<a id="afd5a1ba1991779424a53560817f43cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5a1ba1991779424a53560817f43cf6">&sect;&nbsp;</a></span>coordsToPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::coordsToPixels </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this method to set an own <a class="el" href="classQCPSelectionDecorator.html" title="Controls how a plottable&#39;s data selection is drawn. ">QCPSelectionDecorator</a> (subclass) instance. This allows you to customize the visual representation of selected data ranges further than by using the default <a class="el" href="classQCPSelectionDecorator.html" title="Controls how a plottable&#39;s data selection is drawn. ">QCPSelectionDecorator</a>.</p>
<p>The plottable takes ownership of the <em>decorator</em>.</p>
<p>The currently set decorator can be accessed via selectionDecorator. </p>

</div>
</div>
<a id="a4033ca80db907352e4188162f861d69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4033ca80db907352e4188162f861d69a">&sect;&nbsp;</a></span>selectTest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double QCPPolarGraph::selectTest </td>
          <td>(</td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlySelectable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVariant *&#160;</td>
          <td class="paramname"><em>details</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to decide whether a click hits a layerable object or not.</p>
<p><em>pos</em> is a point in pixel coordinates on the <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> surface. This function returns the shortest pixel distance of this point to the object. If the object is either invisible or the distance couldn't be determined, -1.0 is returned. Further, if <em>onlySelectable</em> is true and the object is not selectable, -1.0 is returned, too.</p>
<p>If the object is represented not by single lines but by an area like a <a class="el" href="classQCPItemText.html">QCPItemText</a> or the bars of a <a class="el" href="classQCPBars.html">QCPBars</a> plottable, a click inside the area should also be considered a hit. In these cases this function thus returns a constant value greater zero but still below the parent plot's selection tolerance. (typically the selectionTolerance multiplied by 0.99).</p>
<p>Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).</p>
<p>The actual setting of the selection state is not done by this function. This is handled by the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> when the mouseReleaseEvent occurs, and the finally selected object is notified via the <a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a>/<a class="el" href="classQCPPolarGraph.html#a3372c079d5859f513d18384890945072">deselectEvent</a> methods.</p>
<p><em>details</em> is an optional output parameter. Every layerable subclass may place any information in <em>details</em>. This information will be passed to <a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a> when the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> decides on the basis of this selectTest call, that the object was successfully selected. The subsequent call to <a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a> will carry the <em>details</em>. This is useful for multi-part objects (like <a class="el" href="classQCPAxis.html" title="Manages a single axis inside a QCustomPlot. ">QCPAxis</a>). This way, a possibly complex calculation to decide which part was clicked is only done once in <a class="el" href="classQCPPolarGraph.html#a4033ca80db907352e4188162f861d69a">selectTest</a>. The result (i.e. the actually clicked part) can then be placed in <em>details</em>. So in the subsequent <a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a>, the decision which part was selected doesn't have to be done a second time for a single selection operation.</p>
<p>In the case of 1D Plottables (<a class="el" href="classQCPAbstractPlottable1D.html">QCPAbstractPlottable1D</a>, like <a class="el" href="classQCPGraph.html">QCPGraph</a> or <a class="el" href="classQCPBars.html">QCPBars</a>) <em>details</em> will be set to a <a class="el" href="classQCPDataSelection.html">QCPDataSelection</a>, describing the closest data point to <em>pos</em>.</p>
<p>You may pass <code>nullptr</code> as <em>details</em> to indicate that you are not interested in those selection details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a>, <a class="el" href="classQCPPolarGraph.html#a3372c079d5859f513d18384890945072">deselectEvent</a>, <a class="el" href="classQCPLayerable.html#af6567604818db90f4fd52822f8bc8376">mousePressEvent</a>, <a class="el" href="classQCPLayerable.html#a47dfd7b8fd99c08ca54e09c362b6f022">wheelEvent</a>, <a class="el" href="classQCustomPlot.html#a5ee1e2f6ae27419deca53e75907c27e5">QCustomPlot::setInteractions</a>, <a class="el" href="classQCPAbstractPlottable1D.html#ac385c38a79e419ed3600c2ee398fd216">QCPAbstractPlottable1D::selectTestRect</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classQCPLayerable.html#a272989087fc8c4357b4ba614f9922336">QCPLayerable</a>.</p>

</div>
</div>
<a id="a9a7713734980adecbe53421795977806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7713734980adecbe53421795977806">&sect;&nbsp;</a></span>clipRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QRect QCPPolarGraph::clipRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the clipping rectangle of this layerable object. By default, this is the viewport of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>. Specific subclasses may reimplement this function to provide different clipping rects.</p>
<p>The returned clipping rect is set on the painter before the draw function of the respective object is called. </p>

<p>Reimplemented from <a class="el" href="classQCPLayerable.html#acbcfc9ecc75433747b1978a77b1864b3">QCPLayerable</a>.</p>

</div>
</div>
<a id="a2a053fc53b7945cd2e3b93cef9cade9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a053fc53b7945cd2e3b93cef9cade9a">&sect;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function draws the layerable with the specified <em>painter</em>. It is only called by <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>, if the layerable is visible (<a class="el" href="classQCPLayerable.html#a3bed99ddc396b48ce3ebfdc0418744f8">setVisible</a>).</p>
<p>Before this function is called, the painter's antialiasing state is set via <a class="el" href="classQCPPolarGraph.html#acc25e8bb9c15d27efdf1d9071bb1e74d">applyDefaultAntialiasingHint</a>, see the documentation there. Further, the clipping rectangle was set to <a class="el" href="classQCPPolarGraph.html#a9a7713734980adecbe53421795977806">clipRect</a>. </p>

<p>Implements <a class="el" href="classQCPLayerable.html#aecf2f7087482d4b6a78cb2770e5ed12d">QCPLayerable</a>.</p>

</div>
</div>
<a id="aad2e0f0209b63f2ba79ef95121b80fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2e0f0209b63f2ba79ef95121b80fab">&sect;&nbsp;</a></span>selectionCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceQCP.html#a2ad6bb6281c7c2d593d4277b44c2b037">QCP::Interaction</a> QCPPolarGraph::selectionCategory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the selection category this layerable shall belong to. The selection category is used in conjunction with <a class="el" href="classQCustomPlot.html#a5ee1e2f6ae27419deca53e75907c27e5">QCustomPlot::setInteractions</a> to control which objects are selectable and which aren't.</p>
<p>Subclasses that don't fit any of the normal <a class="el" href="namespaceQCP.html#a2ad6bb6281c7c2d593d4277b44c2b037">QCP::Interaction</a> values can use <a class="el" href="namespaceQCP.html#a2ad6bb6281c7c2d593d4277b44c2b037af67a50bc26147a13b551b3a625374949">QCP::iSelectOther</a>. This is what the default implementation returns.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCustomPlot.html#a5ee1e2f6ae27419deca53e75907c27e5">QCustomPlot::setInteractions</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classQCPLayerable.html#a908c9edda761886f33893be326dab77d">QCPLayerable</a>.</p>

</div>
</div>
<a id="acc25e8bb9c15d27efdf1d9071bb1e74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc25e8bb9c15d27efdf1d9071bb1e74d">&sect;&nbsp;</a></span>applyDefaultAntialiasingHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::applyDefaultAntialiasingHint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function applies the default antialiasing setting to the specified <em>painter</em>, using the function <a class="el" href="classQCPLayerable.html#acb663e375d2d36dc5c55021ee5a2119b">applyAntialiasingHint</a>. It is the antialiasing state the painter is put in, when <a class="el" href="classQCPPolarGraph.html#a2a053fc53b7945cd2e3b93cef9cade9a">draw</a> is called on the layerable. If the layerable has multiple entities whose antialiasing setting may be specified individually, this function should set the antialiasing state of the most prominent entity. In this case however, the <a class="el" href="classQCPPolarGraph.html#a2a053fc53b7945cd2e3b93cef9cade9a">draw</a> function usually calls the specialized versions of this function before drawing each entity, effectively overriding the setting of the default antialiasing hint.</p>
<p><b>First example:</b> <a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot. ">QCPGraph</a> has multiple entities that have an antialiasing setting: The graph line, fills and scatters. Those can be configured via <a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">QCPGraph::setAntialiased</a>, <a class="el" href="classQCPAbstractPlottable.html#a089d6b5577120239b55c39ed27c39536">QCPGraph::setAntialiasedFill</a> and <a class="el" href="classQCPAbstractPlottable.html#a2f03f067ede2ed4da6f7d0e4777a3f02">QCPGraph::setAntialiasedScatters</a>. Consequently, there isn't only the <a class="el" href="classQCPAbstractPlottable.html#a59a80773c5cefc05a0646ac8e1149ed5">QCPGraph::applyDefaultAntialiasingHint</a> function (which corresponds to the graph line's antialiasing), but specialized ones like <a class="el" href="classQCPAbstractPlottable.html#a8d06a59ea23324cce6330ebf2262c0ed">QCPGraph::applyFillAntialiasingHint</a> and <a class="el" href="classQCPAbstractPlottable.html#ac95f26b15a1e5d9c7bd2c0a46d760fc9">QCPGraph::applyScattersAntialiasingHint</a>. So before drawing one of those entities, <a class="el" href="classQCPGraph.html#a659218cc62c2a7786213d9dd429c1c8d">QCPGraph::draw</a> calls the respective specialized applyAntialiasingHint function.</p>
<p><b>Second example:</b> <a class="el" href="classQCPItemLine.html" title="A line from one point to another. ">QCPItemLine</a> consists only of a line so there is only one antialiasing setting which can be controlled with <a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">QCPItemLine::setAntialiased</a>. (This function is inherited by all layerables. The specialized functions, as seen on <a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot. ">QCPGraph</a>, must be added explicitly to the respective layerable subclass.) Consequently it only has the normal <a class="el" href="classQCPAbstractItem.html#a82a408b38a93be750b934fe847a018cb">QCPItemLine::applyDefaultAntialiasingHint</a>. The <a class="el" href="classQCPItemLine.html#a1fc045dd33919f8006df0692aeb0e84a">QCPItemLine::draw</a> function doesn't need to care about setting any antialiasing states, because the default antialiasing hint is already set on the painter when the <a class="el" href="classQCPPolarGraph.html#a2a053fc53b7945cd2e3b93cef9cade9a">draw</a> function is called, and that's the state it wants to draw the line with. </p>

<p>Implements <a class="el" href="classQCPLayerable.html#afdf83ddc6a265cbf4c89fe99d3d93473">QCPLayerable</a>.</p>

</div>
</div>
<a id="a1bc6a4af76e45ce13cd4f544062ff8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc6a4af76e45ce13cd4f544062ff8b3">&sect;&nbsp;</a></span>selectEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::selectEvent </td>
          <td>(</td>
          <td class="paramtype">QMouseEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>additive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>selectionStateChanged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This event is called when the layerable shall be selected, as a consequence of a click by the user. Subclasses should react to it by setting their selection state appropriately. The default implementation does nothing.</p>
<p><em>event</em> is the mouse event that caused the selection. <em>additive</em> indicates, whether the user was holding the multi-select-modifier while performing the selection (see <a class="el" href="classQCustomPlot.html#a8fc96e3b5138a06759a2a90c166df516">QCustomPlot::setMultiSelectModifier</a>). if <em>additive</em> is true, the selection state must be toggled (i.e. become selected when unselected and unselected when selected).</p>
<p>Every selectEvent is preceded by a call to <a class="el" href="classQCPPolarGraph.html#a4033ca80db907352e4188162f861d69a">selectTest</a>, which has returned positively (i.e. returned a value greater than 0 and less than the selection tolerance of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>). The <em>details</em> data you output from <a class="el" href="classQCPPolarGraph.html#a4033ca80db907352e4188162f861d69a">selectTest</a> is fed back via <em>details</em> here. You may use it to transport any kind of information from the selectTest to the possibly subsequent selectEvent. Usually <em>details</em> is used to transfer which part was clicked, if it is a layerable that has multiple individually selectable parts (like <a class="el" href="classQCPAxis.html" title="Manages a single axis inside a QCustomPlot. ">QCPAxis</a>). This way selectEvent doesn't need to do the calculation again to find out which part was actually clicked.</p>
<p><em>selectionStateChanged</em> is an output parameter. If the pointer is non-null, this function must set the value either to true or false, depending on whether the selection state of this layerable was actually changed. For layerables that only are selectable as a whole and not in parts, this is simple: if <em>additive</em> is true, <em>selectionStateChanged</em> must also be set to true, because the selection toggles. If <em>additive</em> is false, <em>selectionStateChanged</em> is only set to true, if the layerable was previously unselected and now is switched to the selected state.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#a4033ca80db907352e4188162f861d69a">selectTest</a>, <a class="el" href="classQCPPolarGraph.html#a3372c079d5859f513d18384890945072">deselectEvent</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classQCPLayerable.html#a7498c2d0d081cf7cad0fb3bb93aa0e91">QCPLayerable</a>.</p>

</div>
</div>
<a id="a3372c079d5859f513d18384890945072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3372c079d5859f513d18384890945072">&sect;&nbsp;</a></span>deselectEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::deselectEvent </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>selectionStateChanged</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This event is called when the layerable shall be deselected, either as consequence of a user interaction or a call to <a class="el" href="classQCustomPlot.html#a9d4808ab925b003054085246c92a257c">QCustomPlot::deselectAll</a>. Subclasses should react to it by unsetting their selection appropriately.</p>
<p>just as in <a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a>, the output parameter <em>selectionStateChanged</em> (if non-null), must return true or false when the selection state of this layerable has changed or not changed, respectively.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#a4033ca80db907352e4188162f861d69a">selectTest</a>, <a class="el" href="classQCPPolarGraph.html#a1bc6a4af76e45ce13cd4f544062ff8b3">selectEvent</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classQCPLayerable.html#ae546370644a5551c76af739afc008bee">QCPLayerable</a>.</p>

</div>
</div>
<a id="ad9f607151debb2978b4883743c83a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f607151debb2978b4883743c83a2a8">&sect;&nbsp;</a></span>drawLinePlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::drawLinePlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; QPointF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws lines between the points in <em>lines</em>, given in pixel coordinates.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#a4c02b5c9d9ae8cc3e01dffc880d3926d">drawScatterPlot</a>, drawImpulsePlot, <a class="el" href="classQCPAbstractPlottable1D.html#a7adc6c3cccebb5341f11e0c2b7d54206">QCPAbstractPlottable1D::drawPolyline</a> </dd></dl>

</div>
</div>
<a id="a31a42c1816fb6896db565018c2443f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a42c1816fb6896db565018c2443f74">&sect;&nbsp;</a></span>drawFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::drawFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the fill of the graph using the specified <em>painter</em>, with the currently set brush.</p>
<p>Depending on whether a normal fill or a channel fill (setChannelFillGraph) is needed, getFillPolygon or getChannelFillPolygon are used to find the according fill polygons.</p>
<p>In order to handle NaN Data points correctly (the fill needs to be split into disjoint areas), this method first determines a list of non-NaN segments with getNonNanSegments, on which to operate. In the channel fill case, getOverlappingSegments is used to consolidate the non-NaN segments of the two involved graphs, before passing the overlapping pairs to getChannelFillPolygon.</p>
<p>Pass the points of this graph's line as <em>lines</em>, in pixel coordinates.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#ad9f607151debb2978b4883743c83a2a8">drawLinePlot</a>, drawImpulsePlot, <a class="el" href="classQCPPolarGraph.html#a4c02b5c9d9ae8cc3e01dffc880d3926d">drawScatterPlot</a> </dd></dl>

</div>
</div>
<a id="a4c02b5c9d9ae8cc3e01dffc880d3926d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c02b5c9d9ae8cc3e01dffc880d3926d">&sect;&nbsp;</a></span>drawScatterPlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::drawScatterPlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; QPointF &gt; &amp;&#160;</td>
          <td class="paramname"><em>scatters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQCPScatterStyle.html">QCPScatterStyle</a> &amp;&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws scatter symbols at every point passed in <em>scatters</em>, given in pixel coordinates. The scatters will be drawn with <em>painter</em> and have the appearance as specified in <em>style</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQCPPolarGraph.html#ad9f607151debb2978b4883743c83a2a8">drawLinePlot</a>, drawImpulsePlot </dd></dl>

</div>
</div>
<a id="ae3ef86f65cf446fc46a012d3821fc7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ef86f65cf446fc46a012d3821fc7f7">&sect;&nbsp;</a></span>getLines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPPolarGraph::getLines </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQCPDataRange.html">QCPDataRange</a> &amp;&#160;</td>
          <td class="paramname"><em>dataRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method retrieves an optimized set of data points via getOptimizedLineData, an branches out to the line style specific functions such as <a class="el" href="classQCPPolarGraph.html#a2cf5f03ca826775f86b238bca57515c5">dataToLines</a>, dataToStepLeftLines, etc. according to the line style of the graph.</p>
<p><em>lines</em> will be filled with points in pixel coordinates, that can be drawn with the according draw functions like <a class="el" href="classQCPPolarGraph.html#ad9f607151debb2978b4883743c83a2a8">drawLinePlot</a> and drawImpulsePlot. The points returned in <em>lines</em> aren't necessarily the original data points. For example, step line styles require additional points to form the steps when drawn. If the line style of the graph is <a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40a2015a1b1471431d25ddcf35cc6fdef56">lsNone</a>, the <em>lines</em> vector will be empty.</p>
<p><em>dataRange</em> specifies the beginning and ending data indices that will be taken into account for conversion. In this function, the specified range may exceed the total data bounds without harm: a correspondingly trimmed data range will be used. This takes the burden off the user of this function to check for valid indices in <em>dataRange</em>, e.g. when extending ranges coming from getDataSegments.</p>
<dl class="section see"><dt>See also</dt><dd>getScatters </dd></dl>

</div>
</div>
<a id="a2cf5f03ca826775f86b238bca57515c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf5f03ca826775f86b238bca57515c5">&sect;&nbsp;</a></span>dataToLines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt; QPointF &gt; QCPPolarGraph::dataToLines </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classQCPGraphData.html">QCPGraphData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes raw data points in plot coordinates as <em>data</em>, and returns a vector containing pixel coordinate points which are suitable for drawing the line style <a class="el" href="classQCPPolarGraph.html#a1970d7ea3fb60006fad24ce3218e4b40af2efc561134fbc2c971a499877a9449d">lsLine</a>.</p>
<p>The source of <em>data</em> is usually getOptimizedLineData, and this method is called in <em>getLines</em> if the line style is set accordingly.</p>
<dl class="section see"><dt>See also</dt><dd>dataToStepLeftLines, dataToStepRightLines, dataToStepCenterLines, dataToImpulseLines, <a class="el" href="classQCPPolarGraph.html#ae3ef86f65cf446fc46a012d3821fc7f7">getLines</a>, <a class="el" href="classQCPPolarGraph.html#ad9f607151debb2978b4883743c83a2a8">drawLinePlot</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/polar/polargraph.h</li>
<li>src/polar/polargraph.cpp</li>
</ul>
</div><!-- contents -->
</body>
</html>
