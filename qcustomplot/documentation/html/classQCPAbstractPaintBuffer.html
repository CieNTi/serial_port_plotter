<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Emanuel Eichhammer" />
<meta name="copyright" content="(C) 2011-2022 Emanuel Eichhammer" />
<title>QCPAbstractPaintBuffer Class Reference</title>
<link href="qcp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<a class="headerLink"  href="index.html">Main Page</a> &middot;
<a class="headerLink"  href="classoverview.html">Class Overview</a> &middot;
<a class="headerLink"  href="hierarchy.html">Hierarchy</a> &middot;
<a class="headerLink"  href="annotated.html">All Classes</a> &middot;
<a class="headerLink"  href="pages.html">Special Pages</a>
<!-- Generated by Doxygen 1.8.12 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Functions</a> &#124;
<a href="#pro-methods">Protected Functions</a>  </div>
  <div class="headertitle">
<div class="title">QCPAbstractPaintBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The abstract base class for paint buffers, which define the rendering backend.  
 <a href="classQCPAbstractPaintBuffer.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for QCPAbstractPaintBuffer:</div>
<div class="dyncontent">
<div class="center"><img src="classQCPAbstractPaintBuffer__inherit__graph.png" border="0" usemap="#QCPAbstractPaintBuffer_inherit__map" alt="Inheritance graph"/></div>
<map name="QCPAbstractPaintBuffer_inherit__map" id="QCPAbstractPaintBuffer_inherit__map">
<area shape="rect" id="node2" href="classQCPPaintBufferGlFbo.html" title="A paint buffer based on OpenGL frame buffers objects, using hardware accelerated rendering. " alt="" coords="5,77,145,101"/>
<area shape="rect" id="node3" href="classQCPPaintBufferGlPbuffer.html" title="A paint buffer based on OpenGL pixel buffers, using hardware accelerated rendering. " alt="" coords="171,77,333,101"/>
<area shape="rect" id="node4" href="classQCPPaintBufferPixmap.html" title="A paint buffer based on QPixmap, using software raster rendering. " alt="" coords="358,77,508,101"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Functions</h2></td></tr>
<tr class="memitem:a3ce532c12f10b81697108835755641e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#a3ce532c12f10b81697108835755641e2">QCPAbstractPaintBuffer</a> (const QSize &amp;size, double devicePixelRatio)</td></tr>
<tr class="separator:a3ce532c12f10b81697108835755641e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea8284e547985c5d263f26a6adfa11f"><td class="memItemLeft" align="right" valign="top"><a id="a3ea8284e547985c5d263f26a6adfa11f"></a>
QSize&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a3ea8284e547985c5d263f26a6adfa11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bf771cda945a6c602cf9b7d365d92b"><td class="memItemLeft" align="right" valign="top"><a id="a76bf771cda945a6c602cf9b7d365d92b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>invalidated</b> () const</td></tr>
<tr class="separator:a76bf771cda945a6c602cf9b7d365d92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1b981f8c1744036610ff1a6b9461f9"><td class="memItemLeft" align="right" valign="top"><a id="aac1b981f8c1744036610ff1a6b9461f9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>devicePixelRatio</b> () const</td></tr>
<tr class="separator:aac1b981f8c1744036610ff1a6b9461f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b68c3cd36533f1a4a23b5ce8cd66f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#a8b68c3cd36533f1a4a23b5ce8cd66f01">setSize</a> (const QSize &amp;size)</td></tr>
<tr class="separator:a8b68c3cd36533f1a4a23b5ce8cd66f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c7dc70dfc66be2879ce297b2b3d67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#ae4c7dc70dfc66be2879ce297b2b3d67f">setInvalidated</a> (bool invalidated=true)</td></tr>
<tr class="separator:ae4c7dc70dfc66be2879ce297b2b3d67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555eaad5d5c806420ff35602a1bb68fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#a555eaad5d5c806420ff35602a1bb68fa">setDevicePixelRatio</a> (double ratio)</td></tr>
<tr class="separator:a555eaad5d5c806420ff35602a1bb68fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9f29b19c033cf02fb96f1a148463f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#a9e9f29b19c033cf02fb96f1a148463f3">startPainting</a> ()=0</td></tr>
<tr class="separator:a9e9f29b19c033cf02fb96f1a148463f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b0dc6e7744f19fae09f8532c207dc1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#a41b0dc6e7744f19fae09f8532c207dc1">donePainting</a> ()</td></tr>
<tr class="separator:a41b0dc6e7744f19fae09f8532c207dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb998c7525e3ae37d9d2d46c7aaf461a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#afb998c7525e3ae37d9d2d46c7aaf461a">draw</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const =0</td></tr>
<tr class="separator:afb998c7525e3ae37d9d2d46c7aaf461a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e253f4541dfc01992b77e8830bd7722"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#a9e253f4541dfc01992b77e8830bd7722">clear</a> (const QColor &amp;color)=0</td></tr>
<tr class="separator:a9e253f4541dfc01992b77e8830bd7722"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Functions</h2></td></tr>
<tr class="memitem:aee7506a52bd7e5a07c2af27935eb13e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPaintBuffer.html#aee7506a52bd7e5a07c2af27935eb13e7">reallocateBuffer</a> ()=0</td></tr>
<tr class="separator:aee7506a52bd7e5a07c2af27935eb13e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The abstract base class for paint buffers, which define the rendering backend. </p>
<p>This abstract base class defines the basic interface that a paint buffer needs to provide in order to be usable by <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>.</p>
<p>A paint buffer manages both a surface to draw onto, and the matching paint device. The size of the surface can be changed via <a class="el" href="classQCPAbstractPaintBuffer.html#a8b68c3cd36533f1a4a23b5ce8cd66f01">setSize</a>. External classes (<a class="el" href="classQCustomPlot.html">QCustomPlot</a> and <a class="el" href="classQCPLayer.html">QCPLayer</a>) request a painter via <a class="el" href="classQCPAbstractPaintBuffer.html#a9e9f29b19c033cf02fb96f1a148463f3">startPainting</a> and then perform the draw calls. Once the painting is complete, <a class="el" href="classQCPAbstractPaintBuffer.html#a41b0dc6e7744f19fae09f8532c207dc1">donePainting</a> is called, so the paint buffer implementation can do clean up if necessary. Before rendering a frame, each paint buffer is usually filled with a color using <a class="el" href="classQCPAbstractPaintBuffer.html#a9e253f4541dfc01992b77e8830bd7722">clear</a> (usually the color is <code>Qt::transparent</code>), to remove the contents of the previous frame.</p>
<p>The simplest paint buffer implementation is <a class="el" href="classQCPPaintBufferPixmap.html">QCPPaintBufferPixmap</a> which allows regular software rendering via the raster engine. Hardware accelerated rendering via pixel buffers and frame buffer objects is provided by <a class="el" href="classQCPPaintBufferGlPbuffer.html">QCPPaintBufferGlPbuffer</a> and <a class="el" href="classQCPPaintBufferGlFbo.html">QCPPaintBufferGlFbo</a>. They are used automatically if <a class="el" href="classQCustomPlot.html#a7db1adc09016329f3aef7c60da935789">QCustomPlot::setOpenGl</a> is enabled. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3ce532c12f10b81697108835755641e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce532c12f10b81697108835755641e2">&sect;&nbsp;</a></span>QCPAbstractPaintBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QCPAbstractPaintBuffer::QCPAbstractPaintBuffer </td>
          <td>(</td>
          <td class="paramtype">const QSize &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>devicePixelRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a paint buffer and initializes it with the provided <em>size</em> and <em>devicePixelRatio</em>.</p>
<p>Subclasses must call their <a class="el" href="classQCPAbstractPaintBuffer.html#aee7506a52bd7e5a07c2af27935eb13e7">reallocateBuffer</a> implementation in their respective constructors. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8b68c3cd36533f1a4a23b5ce8cd66f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b68c3cd36533f1a4a23b5ce8cd66f01">&sect;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPaintBuffer::setSize </td>
          <td>(</td>
          <td class="paramtype">const QSize &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the paint buffer size.</p>
<p>The buffer is reallocated (by calling <a class="el" href="classQCPAbstractPaintBuffer.html#aee7506a52bd7e5a07c2af27935eb13e7">reallocateBuffer</a>), so any painters that were obtained by <a class="el" href="classQCPAbstractPaintBuffer.html#a9e9f29b19c033cf02fb96f1a148463f3">startPainting</a> are invalidated and must not be used after calling this method.</p>
<p>If <em>size</em> is already the current buffer size, this method does nothing. </p>

</div>
</div>
<a id="ae4c7dc70dfc66be2879ce297b2b3d67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c7dc70dfc66be2879ce297b2b3d67f">&sect;&nbsp;</a></span>setInvalidated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPaintBuffer::setInvalidated </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invalidated</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the invalidated flag to <em>invalidated</em>.</p>
<p>This mechanism is used internally in conjunction with isolated replotting of <a class="el" href="classQCPLayer.html">QCPLayer</a> instances (in <a class="el" href="classQCPLayer.html#a67dcfc1590be2a1f2227c5a39bb59c7cab581b9fab3007c4c65f057f4185d7538">QCPLayer::lmBuffered</a> mode). If <a class="el" href="classQCPLayer.html#adefd53b6db02f470151c416f42e37180">QCPLayer::replot</a> is called on a buffered layer, i.e. an isolated repaint of only that layer (and its dedicated paint buffer) is requested, <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> will decide depending on the invalidated flags of other paint buffers whether it also replots them, instead of only the layer on which the replot was called.</p>
<p>The invalidated flag is set to true when <a class="el" href="classQCPLayer.html">QCPLayer</a> association has changed, i.e. if layers were added or removed from this buffer, or if they were reordered. It is set to false as soon as all associated <a class="el" href="classQCPLayer.html">QCPLayer</a> instances are drawn onto the buffer.</p>
<p>Under normal circumstances, it is not necessary to manually call this method. </p>

</div>
</div>
<a id="a555eaad5d5c806420ff35602a1bb68fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555eaad5d5c806420ff35602a1bb68fa">&sect;&nbsp;</a></span>setDevicePixelRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPaintBuffer::setDevicePixelRatio </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the device pixel ratio to <em>ratio</em>. This is useful to render on high-DPI output devices. The ratio is automatically set to the device pixel ratio used by the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> instance.</p>
<p>The buffer is reallocated (by calling <a class="el" href="classQCPAbstractPaintBuffer.html#aee7506a52bd7e5a07c2af27935eb13e7">reallocateBuffer</a>), so any painters that were obtained by <a class="el" href="classQCPAbstractPaintBuffer.html#a9e9f29b19c033cf02fb96f1a148463f3">startPainting</a> are invalidated and must not be used after calling this method.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only available for Qt versions 5.4 and higher. </dd></dl>

</div>
</div>
<a id="a9e9f29b19c033cf02fb96f1a148463f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9f29b19c033cf02fb96f1a148463f3">&sect;&nbsp;</a></span>startPainting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPPainter.html">QCPPainter</a> * QCPAbstractPaintBuffer::startPainting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classQCPPainter.html">QCPPainter</a> which is ready to draw to this buffer. The ownership and thus the responsibility to delete the painter after the painting operations are complete is given to the caller of this method.</p>
<p>Once you are done using the painter, delete the painter and call <a class="el" href="classQCPAbstractPaintBuffer.html#a41b0dc6e7744f19fae09f8532c207dc1">donePainting</a>.</p>
<p>While a painter generated with this method is active, you must not call <a class="el" href="classQCPAbstractPaintBuffer.html#a8b68c3cd36533f1a4a23b5ce8cd66f01">setSize</a>, <a class="el" href="classQCPAbstractPaintBuffer.html#a555eaad5d5c806420ff35602a1bb68fa">setDevicePixelRatio</a> or <a class="el" href="classQCPAbstractPaintBuffer.html#a9e253f4541dfc01992b77e8830bd7722">clear</a>.</p>
<p>This method may return 0, if a painter couldn't be activated on the buffer. This usually indicates a problem with the respective painting backend. </p>

<p>Implemented in <a class="el" href="classQCPPaintBufferGlFbo.html#a26a67e7d30770513626e1fa56ce7e92a">QCPPaintBufferGlFbo</a>, <a class="el" href="classQCPPaintBufferGlPbuffer.html#aa8c776394ca3de788de7485137668a60">QCPPaintBufferGlPbuffer</a>, and <a class="el" href="classQCPPaintBufferPixmap.html#a48e72ff42a22d1330ad1530658c5ce5c">QCPPaintBufferPixmap</a>.</p>

</div>
</div>
<a id="a41b0dc6e7744f19fae09f8532c207dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b0dc6e7744f19fae09f8532c207dc1">&sect;&nbsp;</a></span>donePainting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPaintBuffer::donePainting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you have acquired a <a class="el" href="classQCPPainter.html">QCPPainter</a> to paint onto this paint buffer via <a class="el" href="classQCPAbstractPaintBuffer.html#a9e9f29b19c033cf02fb96f1a148463f3">startPainting</a>, call this method as soon as you are done with the painting operations and have deleted the painter.</p>
<p>paint buffer subclasses may use this method to perform any type of cleanup that is necessary. The default implementation does nothing. </p>

<p>Reimplemented in <a class="el" href="classQCPPaintBufferGlFbo.html#ae7f157a529e63e375be2c32950ad5a9c">QCPPaintBufferGlFbo</a>.</p>

</div>
</div>
<a id="afb998c7525e3ae37d9d2d46c7aaf461a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb998c7525e3ae37d9d2d46c7aaf461a">&sect;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPaintBuffer::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the contents of this buffer with the provided <em>painter</em>. This is the method that is used to finally join all paint buffers and draw them onto the screen. </p>

<p>Implemented in <a class="el" href="classQCPPaintBufferGlFbo.html#abea347b90aa4ccaa8e754f7ea5446779">QCPPaintBufferGlFbo</a>, <a class="el" href="classQCPPaintBufferGlPbuffer.html#a7253d6a46bb661f35f073bf0a5a2377b">QCPPaintBufferGlPbuffer</a>, and <a class="el" href="classQCPPaintBufferPixmap.html#a60a4a0376c30ebafb55070587fe1896e">QCPPaintBufferPixmap</a>.</p>

</div>
</div>
<a id="a9e253f4541dfc01992b77e8830bd7722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e253f4541dfc01992b77e8830bd7722">&sect;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPaintBuffer::clear </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the entire buffer with the provided <em>color</em>. To have an empty transparent buffer, use the named color <code>Qt::transparent</code>.</p>
<p>This method must not be called if there is currently a painter (acquired with <a class="el" href="classQCPAbstractPaintBuffer.html#a9e9f29b19c033cf02fb96f1a148463f3">startPainting</a>) active. </p>

<p>Implemented in <a class="el" href="classQCPPaintBufferGlFbo.html#a15399ce6ffd20d9d01e2f09b7c232143">QCPPaintBufferGlFbo</a>, <a class="el" href="classQCPPaintBufferGlPbuffer.html#acbbdd88143999bac9f22f2a9cb33fcc9">QCPPaintBufferGlPbuffer</a>, and <a class="el" href="classQCPPaintBufferPixmap.html#aebe5c2726d839047dfab4f0cc0d6086b">QCPPaintBufferPixmap</a>.</p>

</div>
</div>
<a id="aee7506a52bd7e5a07c2af27935eb13e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7506a52bd7e5a07c2af27935eb13e7">&sect;&nbsp;</a></span>reallocateBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPaintBuffer::reallocateBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reallocates the internal buffer with the currently configured size (<a class="el" href="classQCPAbstractPaintBuffer.html#a8b68c3cd36533f1a4a23b5ce8cd66f01">setSize</a>) and device pixel ratio, if applicable (<a class="el" href="classQCPAbstractPaintBuffer.html#a555eaad5d5c806420ff35602a1bb68fa">setDevicePixelRatio</a>). It is called as soon as any of those properties are changed on this paint buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Subclasses of <a class="el" href="classQCPAbstractPaintBuffer.html">QCPAbstractPaintBuffer</a> must call their reimplementation of this method in their constructor, to perform the first allocation (this can not be done by the base class because calling pure virtual methods in base class constructors is not possible). </dd></dl>

<p>Implemented in <a class="el" href="classQCPPaintBufferGlFbo.html#a116e73dfc70ff70f8d196ecdb5256ce5">QCPPaintBufferGlFbo</a>, <a class="el" href="classQCPPaintBufferGlPbuffer.html#a1c2041cef26675a4e3eb1f41e8b82f01">QCPPaintBufferGlPbuffer</a>, and <a class="el" href="classQCPPaintBufferPixmap.html#a644cf6d2584ca597f2d9a128032ed27a">QCPPaintBufferPixmap</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/paintbuffer.h</li>
<li>src/paintbuffer.cpp</li>
</ul>
</div><!-- contents -->
</body>
</html>
