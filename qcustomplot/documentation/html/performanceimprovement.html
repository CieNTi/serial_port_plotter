<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Emanuel Eichhammer" />
<meta name="copyright" content="(C) 2011-2022 Emanuel Eichhammer" />
<title>Plot Performance Improvement</title>
<link href="qcp.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top">
<a class="headerLink"  href="index.html">Main Page</a> &middot;
<a class="headerLink"  href="classoverview.html">Class Overview</a> &middot;
<a class="headerLink"  href="hierarchy.html">Hierarchy</a> &middot;
<a class="headerLink"  href="annotated.html">All Classes</a> &middot;
<a class="headerLink"  href="pages.html">Special Pages</a>
<!-- Generated by Doxygen 1.8.12 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Plot Performance Improvement </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> employs various techniques like adaptive sampling and text object caching in order to cut down the time required to replot. However, some features like complex translucent fills and thick lines can still cause a significant slow down. If you notice this in your application, here are some hints on how to increase replot performance (to benchmark performance, see <a class="el" href="classQCustomPlot.html#ad582e335061a25da006acc58a4009ccc">QCustomPlot::replotTime</a>).</p>
<p>By far the most time is spent in the drawing functions, specifically the drawing of high density graphs and other plottables. For maximum performance, consider the following points:</p>
<ul>
<li>Especially if you are using complex fills under/between graphs, thick lines, translucent colors: enable <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>'s OpenGL hardware accelerated rendering via <a class="el" href="classQCustomPlot.html#a7db1adc09016329f3aef7c60da935789">QCustomPlot::setOpenGl</a>. For details how to correctly enable OpenGL acceleration, see the documentation there. OpenGL acceleration is available for all Qt versions that are supported by <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>, and the respective backend is chosen appropriately. <br />
 For Qt versions before 5.0, an alternative to <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a>'s own OpenGL acceleration is to supply "-graphicssystem opengl" as command line argument or calling <code>QApplication::setGraphicsSystem("opengl")</code> before creating the QApplication object. This enables application wide OpenGL acceleration. <br />
Note that with OpenGL acceleration, the maximum frame rate might be constrained by the vertical sync frequency of your monitor (VSync can be disabled in the graphics card driver configuration). So for simple plots (where the potential framerate is far above 60 frames per second), OpenGL acceleration might achieve numerically lower frame rates than the default software renderer, because it is not capped at the VSync frequency.</li>
</ul>
<ul>
<li>Avoid lines with a pen width greater than one. This is especially relevant with the default software renderer, less so with OpenGL acceleration.</li>
</ul>
<ul>
<li>Avoid complex fills, e.g. channel fills between graphs with thousands of points. This is especially relevant with the default software renderer, less so with OpenGL acceleration.</li>
</ul>
<ul>
<li>If you often need to call a full <a class="el" href="classQCustomPlot.html#aa4bfe7d70dbe67e81d877819b75ab9af">QCustomPlot::replot</a> only because a non-complex object (e.g. an item) has changed while having relatively static but complex graphs in the plot, consider placing the regularly changing objects onto an own layer and setting its mode (<a class="el" href="classQCPLayer.html#a938d57b04f4e4c23cedf1711f983919b">QCPLayer::setMode</a>) to <a class="el" href="classQCPLayer.html#a67dcfc1590be2a1f2227c5a39bb59c7cab581b9fab3007c4c65f057f4185d7538">QCPLayer::lmBuffered</a>. This makes <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> allocate a dedicated paint buffer for this layer, and allows it to be replotted individually with <a class="el" href="classQCPLayer.html#adefd53b6db02f470151c416f42e37180">QCPLayer::replot</a>, independent of the other layers containing the potentially complex and slow graphs. See the documentation of the respective methods for details.</li>
</ul>
<ul>
<li>Qt4 only: Use Qt 4.8 or newer. Performance has doubled or tripled with respect to Qt 4.7. However, QPainter was broken and drawing pixel precise elements like scatters doesn't look as good as with Qt 4.7. So it's a performance vs. plot quality tradeoff when switching to Qt 4.8. <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> internally tries to work around the worst glitches of this kind.</li>
</ul>
<ul>
<li>To increase responsiveness during range dragging, consider setting <a class="el" href="classQCustomPlot.html#a775bdcb6329d44701aeaa6135b0e5265">QCustomPlot::setNoAntialiasingOnDrag</a> to true. This is only relevant if using the default software renderer. (OpenGL antialiasing can't be toggled on-the-fly and would require an expensive reallocation of the sample buffer.)</li>
</ul>
<ul>
<li>Consider using setAttribute(Qt::WA_OpaquePaintEvent) on the <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> widget. This allows to save one fill at every paint event. Note though that on embedded systems, this may prevent Qt from graying out the widget together with the rest of the UI, when a modal dialog is shown.</li>
</ul>
<ul>
<li>Qt4 only: On X11 (GNU/Linux), avoid the slow native drawing system, use <em>raster</em> by supplying "-graphicssystem raster" as command line argument or calling <code>QApplication::setGraphicsSystem("raster")</code> before creating the QApplication object.</li>
</ul>
<ul>
<li>Avoid any kind of alpha (transparency) colors, especially in fills.</li>
</ul>
<ul>
<li>Avoid any kind of antialiasing, especially in graph lines (see <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>). This is only relevant if using the default software renderer.</li>
</ul>
<ul>
<li>Avoid repeatedly setting the complete data set e.g. with <a class="el" href="classQCPGraph.html#a1eae9429a316b008e2d99b2d65a54395">QCPGraph::setData</a>. Use <a class="el" href="classQCPGraph.html#ae0555c0d3fe0fa7cb8628f88158d420f">QCPGraph::addData</a> instead, if most data points stay unchanged, e.g. in a running measurement. You can access and manipulate existing data via <a class="el" href="classQCPGraph.html#a141aa31a1f19bbd0ce60f55eaeb9ea60">QCPGraph::data</a>.</li>
</ul>
<ul>
<li>As a last resort, try to reduce the number of data points that are in the visible key range at any given moment, e.g. by limiting the maximum key range span (see the <a class="el" href="classQCPAxis.html#a0894084e4c16a1736534c4095746f910">QCPAxis::rangeChanged</a> signal). <a class="el" href="classQCustomPlot.html" title="The central class of the library. This is the QWidget which displays the plot and interacts with the ...">QCustomPlot</a> can optimize away millions of off-screen points very efficiently. </li>
</ul>
</div></div><!-- contents -->
</body>
</html>
